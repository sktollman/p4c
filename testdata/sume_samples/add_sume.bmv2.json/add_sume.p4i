# 1 "add_sume.p4"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "add_sume.p4"

# 1 "/usr/local/share/p4c/p4include/core.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */




/// Standard error codes.  New error codes can be declared by users.
error {
    NoError, /// No error.
    PacketTooShort, /// Not enough bits in packet for 'extract'.
    NoMatch, /// 'select' expression has no matches.
    StackOutOfBounds, /// Reference to invalid element of a header stack.
    HeaderTooShort, /// Extracting too many bits into a varbit field.
    ParserTimeout /// Parser execution time limit exceeded.
}

extern packet_in {
    /// Read a header from the packet into a fixed-sized header @hdr and advance the cursor.
    /// May trigger error PacketTooShort or StackOutOfBounds.
    /// @T must be a fixed-size header type
    void extract<T>(out T hdr);
    /// Read bits from the packet into a variable-sized header @variableSizeHeader
    /// and advance the cursor.
    /// @T must be a header containing exactly 1 varbit field.
    /// May trigger errors PacketTooShort, StackOutOfBounds, or HeaderTooShort.
    void extract<T>(out T variableSizeHeader,
                    in bit<32> variableFieldSizeInBits);
    /// Read bits from the packet without advancing the cursor.
    /// @returns: the bits read from the packet.
    /// T may be an arbitrary fixed-size type.
    T lookahead<T>();
    /// Advance the packet cursor by the specified number of bits.
    void advance(in bit<32> sizeInBits);
    /// @return packet length in bytes.  This method may be unavailable on
    /// some target architectures.
    bit<32> length();
}

extern packet_out {
    /// Write @hdr into the output packet, advancing cursor.
    /// @T can be a header type, a header stack, a header_union, or a struct
    /// containing fields with such types.
    void emit<T>(in T hdr);
}

// TODO: remove from this file, convert to built-in
/// Check a predicate @check in the parser; if the predicate is true do nothing,
/// otherwise set the parser error to @toSignal, and transition to the `reject` state.
extern void verify(in bool check, in error toSignal);

/// Built-in action that does nothing.
action NoAction() {}

/// Standard match kinds for table key fields.
/// Some architectures may not support all these match kinds.
/// Architectures can declare additional match kinds.
match_kind {
    /// Match bits exactly.
    exact,
    /// Ternary match, using a mask.
    ternary,
    /// Longest-prefix match.
    lpm
}
# 3 "add_sume.p4" 2
# 1 "/usr/local/share/p4c/p4include/sume_switch.p4" 1
//----------------------------------------------------------------------------
//   This file is owned and controlled by Xilinx and must be used solely    //
//   for design, simulation, implementation and creation of design files    //
//   limited to Xilinx devices or technologies. Use with non-Xilinx         //
//   devices or technologies is expressly prohibited and immediately        //
//   terminates your license.                                               //
//                                                                          //
//   XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY   //
//   FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY   //
//   PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE            //
//   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS     //
//   MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY     //
//   CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY      //
//   RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY      //
//   DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE  //
//   IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         //
//   REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        //
//   INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  //
//   PARTICULAR PURPOSE.                                                    //
//                                                                          //
//   Xilinx products are not intended for use in life support appliances,   //
//   devices, or systems.  Use in such applications are expressly           //
//   prohibited.                                                            //
//                                                                          //
//   (c) Copyright 1995-2017 Xilinx, Inc.                                   //
//   All rights reserved.                                                   //
//----------------------------------------------------------------------------



// File "simple_sume_switch.p4"
// NetFPGA SUME P4 Switch declaration
// core library needed for packet_in definition
# 1 "/usr/local/share/p4c/p4include/core.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */
# 35 "/usr/local/share/p4c/p4include/sume_switch.p4" 2

// one-hot encoded: {DMA, NF3, DMA, NF2, DMA, NF1, DMA, NF0}
typedef bit<8> port_t;

/* standard sume switch metadata */
// @metadata @name("sume_metadata") TODO: should I have this?
struct sume_metadata_t {
    bit<16> dma_q_size; // measured in 32-byte words
    bit<16> nf3_q_size; // measured in 32-byte words
    bit<16> nf2_q_size; // measured in 32-byte words
    bit<16> nf1_q_size; // measured in 32-byte words
    bit<16> nf0_q_size; // measured in 32-byte words
    bit<8> send_dig_to_cpu; // send digest_data to CPU
    bit<8> drop;
    port_t dst_port; // one-hot encoded: {DMA, NF3, DMA, NF2, DMA, NF1, DMA, NF0}
    port_t src_port; // one-hot encoded: {DMA, NF3, DMA, NF2, DMA, NF1, DMA, NF0}
    bit<16> pkt_len; // unsigned int
}

/**
 * Programmable parser.
 * @param b input packet
 * @param <H> type of headers; defined by user
 * @param parsedHeaders headers constructed by parser
 * @param <M> type of metadata; defined by user
 * @param metadata; metadata constructed by parser
 * @param sume_metadata; standard metadata for the sume switch
 */
parser Parser<H, M, D>(packet_in b,
                       out H parsedHeaders,
                       out M user_metadata,
                       out D digest_data,
                       inout sume_metadata_t sume_metadata);

/**
 * Match-action pipeline
 * @param <H> type of input and output headers
 * @param parsedHeaders; headers received from the parser and sent to the deparser
 * @param <M> type of input and output user metadata
 * @param user_metadata; metadata defined by the user
 * @param sume_metadata; standard metadata for the sume switch
 */
control Pipe<H, M, D>(inout H parsedHeaders,
                      inout M user_metadata,
                      inout D digest_data,
                      inout sume_metadata_t sume_metadata);

/**
 * Switch deparser.
 * @param b output packet
 * @param <H> type of headers; defined by user
 * @param parsedHeaders headers for output packet
 * @param <M> type of metadata; defined by user
 * @param user_metadata; defined by user
 * @param sume_metadata; standard metadata for the sume switch
 */
control Deparser<H, M, D>(packet_out b,
                          in H parsedHeaders,
                          in M user_metadata,
                          inout D digest_data,
                          inout sume_metadata_t sume_metadata);

/**
 * Top-level package declaration - must be instantiated by user.
 * The arguments to the package indicate blocks that
 * must be instantiated by the user.
 * @param <H> user-defined type of the headers processed.
 */
package SimpleSumeSwitch<H, M, D>(Parser<H, M, D> p,
                                  Pipe<H, M, D> map,
                                  Deparser<H, M, D> d);
# 4 "add_sume.p4" 2

/*
  Simple program to add two numbers together
 */

typedef bit<48> EthAddr_t;
typedef bit<32> calcField_t;



// define opCode types



// standard Ethernet header
header Ethernet_h {
    EthAddr_t dstAddr;
    EthAddr_t srcAddr;
    bit<16> etherType;
}

header Calc_h {
    calcField_t op1;
    bit<8> opCode;
    calcField_t op2;
    calcField_t result;
}


// List of all recognized headers
struct Parsed_packet {
    Ethernet_h ethernet;
    Calc_h calc;
}

// user defined metadata: can be used to share information between
// TopParser, TopPipe, and TopDeparser
struct user_metadata_t {
    bit<8> unused;
}

// digest_data, MUST be 256 bits
struct digest_data_t {
    bit<256> unused;
}

// Parser Implementation
// @Xilinx_MaxPacketRegion(1024) - TODO: figure out if this messes with anything
parser TopParser(packet_in b,
                 out Parsed_packet p,
                 out user_metadata_t user_metadata,
                 out digest_data_t digest_data,
                 inout sume_metadata_t sume_metadata) {
    state start {
        b.extract(p.ethernet);
        user_metadata.unused = 0;
        digest_data.unused = 0;
        transition select(p.ethernet.etherType) {
            0x1212: parse_calc;
            default: accept;
        }
    }

    state parse_calc {
        b.extract(p.calc);
        transition accept;
    }
}

// match-action pipeline
control TopPipe(inout Parsed_packet p,
                inout user_metadata_t user_metadata,
                inout digest_data_t digest_data,
                inout sume_metadata_t sume_metadata) {

    action swap_eth_addresses() {
        EthAddr_t temp = p.ethernet.dstAddr;
        p.ethernet.dstAddr = p.ethernet.srcAddr;
        p.ethernet.srcAddr = temp;
    }

    action set_output_port() {
        sume_metadata.dst_port = sume_metadata.src_port;
    }

    action set_result(calcField_t data) {
        p.calc.result = data;
    }

    action set_result_default() {
        p.calc.result = 32w0;
    }

    table lookup_table {
        key = { p.calc.op1: exact; }

        actions = {
            set_result;
            set_result_default;
        }
        size = 64;
        default_action = set_result_default;
    }

    apply {

        // bounce packet back to sender
        swap_eth_addresses();
        set_output_port();

        // based on the opCode, set the result or state appropriately
        if (p.calc.opCode == 8w0) {
            p.calc.result = p.calc.op1 + p.calc.op2;
        } else if (p.calc.opCode == 8w2) {
            lookup_table.apply();
        }

    }
}

// Deparser Implementation
//@Xilinx_MaxPacketRegion(1024)
control TopDeparser(packet_out b,
                    in Parsed_packet p,
                    in user_metadata_t user_metadata,
                    inout digest_data_t digest_data,
                    inout sume_metadata_t sume_metadata) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.calc);
    }
}


// Instantiate the switch
SimpleSumeSwitch(TopParser(), TopPipe(), TopDeparser()) main;
